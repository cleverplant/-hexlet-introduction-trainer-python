#  Цикл while

'''
Программы, которые мы пишем, становятся всё сложнее и объемнее.
Они все ещё очень далеки от реальных программ, где количество строк кода измеряется десятками 
и сотнями тысяч (а иногда и миллионами), но текущая сложность уже способна заставить напрячься 
людей без опыта. 
Начиная с этого урока, мы переходим к одной из самых сложных базовых тем в программировании – циклам.

Любые прикладные программы служат очень прагматичным целям. Они помогают управлять сотрудниками, 
финансами, развлекают, в конце концов. Несмотря на различия, все эти программы выполняют заложенные 
в них алгоритмы, которые очень похожи между собой. Что это такое? 
Алгоритм — это последовательность действий (инструкций), 
которая приводит нас к некоему ожидаемому результату. 
В принципе, это описание подходит под любую программу, но под алгоритмами обычно понимается 
что-то более специфичное.

Представьте себе, что у нас есть книга и мы хотим найти внутри неё какую-то конкретную фразу. 
Саму фразу мы помним, но не знаем, на какой она странице. Как найти нужную страницу? 
Самый простой (и долгий) способ — последовательно просматривать страницы до тех пор, 
пока мы не найдем нужную. 
В худшем случае придется просмотреть все страницы, но результат мы всё равно получим. 
Именно этот процесс и называется алгоритмом. Он включает в себя логические проверки (нашли ли фразу) 
и перебор страниц. 
Количество страниц, которое придется посмотреть, заранее не известно, но сам процесс просмотра повторяется 
из раза в раз совершенно одинаковым образом. Для выполнения повторяющихся действий как раз и нужны циклы. 
Каждый повтор, в таком случае, называется итерацией.

Напишем функцию с простым циклом, который будет n раз выводить на экран строку 'Hello!':
'''
print('========================================================================')

def print_hello(n):
  counter = 0
  while counter < n:
    print('Hello!')
    counter = counter + 1

print_hello(2)
# => Hello!
# => Hello!
print('========================================================================')

'''
Теперь подробно проанализируем пример функции с циклом, 
который выводит на экран числа от 1 до числа-аргумента:
'''
# print_numbers(3)
# => 1
# => 2
# => 3
'''
Эту функцию невозможно реализовать уже изученными средствами, 
так как количество выводов на экран заранее не известно. 
А с циклами это не составит никаких проблем:'''
print('========================================================================')

def print_numbers(last_number):
  # i сокращение от index (порядковый номер)
  # используется по общему соглашению во множестве языков
  # как счетчик цикла
  i = 1
  while i <= last_number:
      print(i)
      i = i + 1
  print('finished!')

print_numbers(3)
# => 1
# => 2
# => 3
# => finished!
'''========================================================================'''

'''Цикл while состоит из трёх элементов:

=> Ключевое слово while.
=> Предикат. Условие, которое указывается после while. Это условие вычисляется на каждой ИТЕРАЦИИ.
=> Блок кода (тело цикла).
=> Каждое выполнение тела называется ИТЕРАЦИЕЙ. 

В нашем примере вызов print_numbers(3) породил три итерации, 
на каждой из которых была выведена на экран переменная i. 

Конструкция читается так: 
«делать то, что указано в теле цикла пока истинно условие (предикат) i <= last_number». 
Разберём работу этого кода для вызова print_numbers(3):

# Инициализируется i
i = 1

# Предикат возвращает true, поэтому выполняется тело цикла
while 1 <= 3
# print(1)
# i = 1 + 1

# Закончилось тело цикла, поэтому происходит возврат в начало
while 2 <= 3
# print(2)
# i = 2 + 1

# Закончилось тело цикла, поэтому происходит возврат в начало
while 3 <= 3
# print(3)
# i = 3 + 1

# Предикат возвращает false, поэтому выполнение переходит за цикл
while 4 <= 3

# print('finished!');

# На этом этапе i равен 4, но он нам уже не нужен
# функция завершается
'''
'''
Самое главное в цикле — завершение (выход). Процесс, который порождает цикл, 
должен в конце концов остановиться. Ответственность за остановку полностью лежит на программисте. 
Обычно задача сводится к введению переменной, называемой «счётчиком цикла». Сначала он инициализируется, 
то есть ему задаётся начальное значение. В нашем примере это строчка i = 1. 
Затем в условии цикла проверяется, не достиг ли счётчик своего предельного значения.

В нашем примере предельное значение определяется аргументом функции. Если условие цикла не выполнено, 
то тело не выполняется и интерпретатор двигается дальше, выполняя инструкции после цикла. 
Но если условие цикла истинно, то выполняется тело, в котором находится ключевой элемент остановки 
— изменение счетчика. Обычно его делают в конце тела, и это изменение — одно из редких мест, 
где невозможно обойтись без переменной. В нашем примере за изменение отвечает строчка i = i + 1.

На этом моменте новички делают больше всего ошибок. 
Например, случайно забытое увеличение счётчика или неправильная проверка в УСЛОВИИ (предикате) 
способны привести к зацикливанию. Это ситуация, при которой цикл работает бесконечно 
и программа никогда не останавливается. 
В таком случае приходится её завершать принудительно 
(кто знает, может быть когда зависают реальные программы, 
в этот момент внутри них выполняется бесконечный цикл).'''
print('===============  BEGIN  ===============================================')

def print_numbers(last_number):
  i = 1 # 
  # Этот цикл никогда не остановится
  # и будет печатать всегда одно значение
  while i <= last_number:
      print(i) 
print('===============finished 1===============================================')

def print_numbers(last_number):
  i = 1  # <======== 1) Сначала счетчик инициализируется, то есть ему задаётся начальное значение
  while i <= last_number: # 3) Затем в условии цикла проверяется, не достиг ли счётчик своего предельного значения.
      print(i) # <== 4) действие
      i = i + 1 # <= 2) После нужно ввести счетчик цикла i = i + 1
  print('finished!')
# Если условие цикла не выполнено, ( i <= 3 )
# то тело не выполняется и интерпретатор двигается дальше, 
# выполняя инструкции после цикла => print('finished!')
print_numbers(3) # <= 4) Предельное значение определяется аргументом функции

# Но если условие цикла истинно, то выполняется тело, в котором находится элемент остановки 
# — изменение счетчика => i = i + 1.


print('===============finished 2===============================================')
'''
В некоторых случаях бесконечные циклы полезны. Здесь мы такие случаи не рассматриваем, 
но полезно видеть как выглядит этот код:'''  

'''В некоторых случаях бесконечные циклы полезны. Здесь мы такие случаи не рассматриваем, но полезно видеть как выглядит этот код:

while True:
  # Что-то делаем
Подводя итог. 
Когда всё же нужны циклы, а когда можно обойтись без них? 
Физически невозможно обойтись без циклов тогда, когда алгоритм решения задачи 
требует повторения каких-то действий, как в примере с книгой, 
и количество этих операций заранее неизвестно.'''
#  ===============================================================================
'''Синтаксический сахар'''
#  ===============================================================================

'''
Подобные конструкции index = index + 1 в Python используются довольно часто, 
поэтому создатели языка добавили сокращённый вариант записи: index += 1.

Важно понимать, что отличия исключительно в способе записи. 
Интерпретатор превращает сокращённую конструкцию в развёрнутую.

Такие сокращения принято называть синтаксическим сахаром, 
потому что они делают процесс написания кода немного проще и приятнее, «подслащивая» его :)

Существуют сокращённые формы для всех арифметических операций и для конкатенации строк:
'''
#  a = a + 1 → a += 1
#  a = a - 1 → a -= 1
#  a = a * 2 → a *= 2
#  a = a / 1 → a /= 1

a = 4
a -= 8 - a
# a = (a - 8) - a => 2a - 8 -> 2*4 - 8
print(a)


