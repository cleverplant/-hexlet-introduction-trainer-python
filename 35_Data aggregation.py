# Data aggregation
# Агрегация данных 
'''
Агрегация, когда один объект входит в состав другого (может быть компонент одного класса в другой)
Агрегация — это процесс превращения значений набора данных в одно значение.'''

'''
Отдельный класс задач, который не может обойтись без циклов, называется агрегированием данных. 
К таким задачам относятся поиск максимального, минимального, суммы, среднего арифметического и т.п. 
Их главная особенность в том, что результат зависит от всего набора данных. 
Для расчёта суммы нужно сложить все числа, для вычисления максимального нужно сравнить все числа. 
С такими задачами хорошо знакомы все, кто занимаются числами, например бухгалтеры или маркетологи. 
Обычно их выполняют в таблицах наподобие Microsoft Excel или Google Tables.'''

''' ================   Числа  ==================================================

Разберём самый простой пример – поиск суммы набора чисел. 
Реализуем функцию, которая складывает числа в указанном диапазоне, включая границы. 
Диапазоном в данном случае называется ряд чисел от какого-то начала до определенного конца. 
Например, диапазон [1, 10] включает в себя все целые числа от 1 до 10.'''

#  sum_numbers_from_range(5, 7)  # 5 + 6 + 7 = 18
#  sum_numbers_from_range(1, 2)  # 1 + 2 = 3

#  [1, 1] диапазон с одинаковым началом и концом – тоже диапазон
#  он в себя включает ровно одно число – саму границу диапазона
#  sum_numbers_from_range(1, 1)      # 1
#  sum_numbers_from_range(100, 100)  # 100

'''
Для реализации этого кода нам понадобится цикл, 
так как сложение чисел – это итеративный процесс (он повторяется для каждого числа), 
а количество итераций зависит от размера диапазона. 
Перед тем, как смотреть код, попробуйте ответьте на вопросы ниже:

- Каким значением инициализировать счетчик?
- Как он будет изменяться?
- Когда цикл должен остановиться?
- Попробуйте сначала подумать над этими вопросами, а затем посмотрите код ниже:'''
print('=========================================================================')
def sum_numbers_from_range(start, finish):
    # Технически можно менять start
    # Но входные аргументы нужно оставлять в исходном значении
    # Это сделает код проще для анализа
    i = start
    sum = 0  # Инициализация суммы
    while i <= finish:  # Двигаемся до конца диапазона
        sum = sum + i   # Считаем сумму для каждого числа 
                        # (не надо было в примере i ставить, а просто число...)
        i = i + 1       # Переходим к следующему числу в диапазоне
    # Возвращаем получившийся результат
    return sum

print('=================внизу моя фантазия на 3 аргумента=============================================')

def sum_asum(start,asum, finish):
    
    i = start # Инициализация счетчика
    sum = 0   # Инициализация суммы

    while i <= finish:  # Двигаемся до конца диапазона (от i = start до finish)
        asum = asum + i
        sum = sum + 25   # Считаем сумму для каждого числа 
                        # (не надо было в примере i ставить, а просто число...)
        i = i + 1       # Переходим к следующему числу в диапазоне

    # Возвращаем получившийся результат
    return sum, asum # <= сам додумался перечислить через запятую 
print(sum_asum(1,34,12))

print('=========================================================================')
'''
Общая структура цикла здесь стандартна. 
Есть счетчик, который инициализируется начальным значением диапазона, 
есть сам цикл с условием остановки при достижении конца диапазона, 
и, наконец, изменение счетчика в конце тела цикла. 
Количество итераций в таком цикле равно finish - start + 1. 
То есть для диапазона от 5 до 7 – это 7 - 5 + 1, то есть 3 итерации.

Главные отличия от обычной обработки связаны с логикой вычислений результата. 
В задачах на агрегацию всегда есть какая-то переменная, 
которая хранит внутри себя результат работы цикла. В коде выше это sum. 
На каждой итерации цикла происходит её изменение, 
прибавление следующего числа в диапазоне: sum = sum + i. Весь процесс выглядит так:'''    

# Для вызова sum_numbers_from_range(2, 5)
sum = 0
sum = sum + 2  # 2
sum = sum + 3  # 5
sum = sum + 4  # 9
sum = sum + 5  # 14
# 14 – результат сложения чисел в диапазоне [2, 5]

'''
У переменной sum есть начальное значение, равное 0. Зачем вообще задавать значение? 
Любая повторяющаяся операция начинается с какого-то значения. 
В математике существует понятие нейтральный элемент операции (у каждой операции свой элемент). 
Это понятие имеет очень простой смысл. 
Операция с этим элементом не изменяет то значение, над которым проводится операция. 
В сложении любое число плюс ноль дает само число. 
При вычитании – тоже самое. 
Даже у конкатенации есть нейтральный элемент – это пустая строка: '' + 'one' будет 'one'.

Вопрос на самопроверку. Какой нейтральный элемент у операции умножения?'''

'''======================     Строки     =================================================

Агрегация применяется не только к числам, но и к строкам. 
Это такие задачи, в которых строка формируется динамически, 
то есть заранее неизвестно, какого она размера и что будет содержать.

Представьте себе функцию, которая умеет «умножать» строку, 
то есть она повторяет её указанное количество раз:'''

#  repeat('hexlet', 3)  # 'hexlethexlethexlet'
print('hexlet' * 3)
'''
Принцип работы этой функции довольно простой: 
в цикле происходит «наращивание» строки указанное количество раз:'''

def repeat(text, times):
    # Нейтральный элемент для строк – пустая строка
    result = ''
    i = 1

    while i <= times:
        # Каждый раз добавляем строку к результату
        result = result + text
        i = i + 1

    return result

'''Распишем выполнение этого кода по шагам:'''    

# Для вызова repeat('hexlet', 3)
result = ''
result = result + 'hexlet'  # hexlet
result = result + 'hexlet'  # hexlethexlet
result = result + 'hexlet'  # hexlethexlethexlet





